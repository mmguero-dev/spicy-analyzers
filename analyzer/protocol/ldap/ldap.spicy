module ldap;

import asn1;

# https://tools.ietf.org/html/rfc4511#
# https://ldap.com/ldapv3-wire-protocol-reference-asn1-ber/
# https://lapo.it/asn1js

#- Operation opcode ----------------------------------------------------------
public type ProtocolOpcode = enum {
  BIND_REQUEST            = 0,
  BIND_RESPONSE           = 1,
  UNBIND_REQUEST          = 2,
  SEARCH_REQUEST          = 3,
  SEARCH_RESULT_ENTRY     = 4,
  SEARCH_RESULT_DONE      = 5,
  MODIFY_REQUEST          = 6,
  MODIFY_RESPONSE         = 7,
  ADD_REQUEST             = 8,
  ADD_RESPONSE            = 9,
  DEL_REQUEST             = 10,
  DEL_RESPONSE            = 11,
  MOD_DN_REQUEST          = 12,
  MOD_DN_RESPONSE         = 13,
  COMPARE_REQUEST         = 14,
  COMPARE_RESPONSE        = 15,
  ABANDON_REQUEST         = 16,
  SEARCH_RESULT_REFERENCE = 19,
  EXTENDED_REQUEST        = 23,
  EXTENDED_RESPONSE       = 24,
  INTERMEDIATE_RESPONSE   = 25,
  NOT_SET                 = 255
};

#- Result code ---------------------------------------------------------------
public type ResultCode = enum {
  SUCCESS                         = 0,
  OPERATIONS_ERROR                = 1,
  PROTOCOL_ERROR                  = 2,
  TIME_LIMIT_EXCEEDED             = 3,
  SIZE_LIMIT_EXCEEDED             = 4,
  COMPARE_FALSE                   = 5,
  COMPARE_TRUE                    = 6,
  AUTH_METHOD_NOT_SUPPORTED       = 7,
  STRONGER_AUTH_REQUIRED          = 8,
  REFERRAL                        = 10,
  ADMIN_LIMIT_EXCEEDED            = 11,
  UNAVAILABLE_CRITICAL_EXTENSION  = 12,
  CONFIDENTIALITY_REQUIRED        = 13,
  SASL_BIND_IN_PROGRESS           = 14,
  NO_SUCH_ATTRIBUTE               = 16,
  UNDEFINED_ATTRIBUTE_TYPE        = 17,
  INAPPROPRIATE_MATCHING          = 18,
  CONSTRAINT_VIOLATION            = 19,
  ATTRIBUTE_OR_VALUE_EXISTS       = 20,
  INVALID_ATTRIBUTE_SYNTAX        = 21,
  NO_SUCH_OBJECT                  = 32,
  ALIAS_PROBLEM                   = 33,
  INVALID_DNSYNTAX                = 34,
  ALIAS_DEREFERENCING_PROBLEM     = 36,
  INAPPROPRIATE_AUTHENTICATION    = 48,
  INVALID_CREDENTIALS             = 49,
  INSUFFICIENT_ACCESS_RIGHTS      = 50,
  BUSY                            = 51,
  UNAVAILABLE                     = 52,
  UNWILLING_TO_PERFORM            = 53,
  LOOP_DETECT                     = 54,
  NAMING_VIOLATION                = 64,
  OBJECT_CLASS_VIOLATION          = 65,
  NOT_ALLOWED_ON_NON_LEAF         = 66,
  NOT_ALLOWED_ON_RDN              = 67,
  ENTRY_ALREADY_EXISTS            = 68,
  OBJECT_CLASS_MODS_PROHIBITED    = 69,
  AFFECTS_MULTIPLE_DSAS           = 71,
  OTHER                           = 80,
  NOT_SET                         = 255
};

#-----------------------------------------------------------------------------
public type Result = unit(depth: uint32) {
  code: asn1::ASN1Message(True, depth) &convert=cast<ResultCode>(cast<uint8>($$.body.num_value))
                                       &default=ResultCode::NOT_SET;
  matchedDN: asn1::ASN1Message(True, depth) &convert=$$.body.octetstring
                                            &default="";
  diagnosticMessage: asn1::ASN1Message(True, depth) &convert=$$.body.octetstring
                                                    &default="";

  # TODO: if we want to parse referral URIs in result
  # https://tools.ietf.org/html/rfc4511#section-4.1.10
};

#-----------------------------------------------------------------------------
public type Messages = unit {
  : Message[];
};

public type Message = unit {
  var messageID: int64;
  var opcode: ProtocolOpcode = ProtocolOpcode::NOT_SET;
  var applicationBytes: bytes;
  var unsetResultDefault: Result;
  var result: Result& = self.unsetResultDefault;
  var obj: string = "";
  var arg: string = "";

  seq: asn1::ASN1Message(True, 0) {
    if ((self.seq.head.tag.tpe == asn1::ASN1Type::SEQUENCE) &&
        (self.seq.body?.seq) &&
        (|self.seq.body.seq.submessages| >= 2)) {
      if (self.seq.body.seq.submessages[0].body?.num_value) {
        self.messageID = self.seq.body.seq.submessages[0].body.num_value;
      }
      if (self.seq.body.seq.submessages[1]?.application_id) {
        self.opcode = cast<ProtocolOpcode>(cast<uint8>(self.seq.body.seq.submessages[1].application_id));
        self.applicationBytes = self.seq.body.seq.submessages[1].application_data;
      }
    }
    if ((! self?.messageID) ||
        (! self?.opcode) ||
        (self.opcode == ProtocolOpcode::NOT_SET)) {
      throw "LDAP message is not ASN.1 sequence as described in RFC 4511";
    }
  }

  switch ( self.opcode ) {
    ProtocolOpcode::BIND_REQUEST            -> BIND_REQUEST:            BindRequest(self)           &parse-from=self.applicationBytes;
    ProtocolOpcode::BIND_RESPONSE           -> BIND_RESPONSE:           BindResponse(self)          &parse-from=self.applicationBytes;
    ProtocolOpcode::UNBIND_REQUEST          -> UNBIND_REQUEST:          UnbindRequest(self)         &parse-from=self.applicationBytes;
    ProtocolOpcode::SEARCH_REQUEST          -> SEARCH_REQUEST:          SearchRequest(self)         &parse-from=self.applicationBytes;
    ProtocolOpcode::SEARCH_RESULT_ENTRY     -> SEARCH_RESULT_ENTRY:     SearchResultEntry(self)     &parse-from=self.applicationBytes;
    ProtocolOpcode::SEARCH_RESULT_DONE      -> SEARCH_RESULT_DONE:      SearchResultDone(self)      &parse-from=self.applicationBytes;
    ProtocolOpcode::MODIFY_REQUEST          -> MODIFY_REQUEST:          ModifyRequest(self)         &parse-from=self.applicationBytes;
    ProtocolOpcode::MODIFY_RESPONSE         -> MODIFY_RESPONSE:         ModifyResponse(self)        &parse-from=self.applicationBytes;
    ProtocolOpcode::ADD_REQUEST             -> ADD_REQUEST:             AddRequest(self)            &parse-from=self.applicationBytes;
    ProtocolOpcode::ADD_RESPONSE            -> ADD_RESPONSE:            AddResponse(self)           &parse-from=self.applicationBytes;
    ProtocolOpcode::DEL_REQUEST             -> DEL_REQUEST:             DelRequest(self)            &parse-from=self.applicationBytes;
    ProtocolOpcode::DEL_RESPONSE            -> DEL_RESPONSE:            DelResponse(self)           &parse-from=self.applicationBytes;
    ProtocolOpcode::MOD_DN_REQUEST          -> MOD_DN_REQUEST:          ModDNRequest(self)          &parse-from=self.applicationBytes;
    ProtocolOpcode::MOD_DN_RESPONSE         -> MOD_DN_RESPONSE:         ModDNResponse(self)         &parse-from=self.applicationBytes;
    ProtocolOpcode::COMPARE_REQUEST         -> COMPARE_REQUEST:         CompareRequest(self)        &parse-from=self.applicationBytes;
    ProtocolOpcode::COMPARE_RESPONSE        -> COMPARE_RESPONSE:        CompareResponse(self)       &parse-from=self.applicationBytes;
    ProtocolOpcode::ABANDON_REQUEST         -> ABANDON_REQUEST:         AbandonRequest(self)        &parse-from=self.applicationBytes;
    ProtocolOpcode::SEARCH_RESULT_REFERENCE -> SEARCH_RESULT_REFERENCE: SearchResultReference(self) &parse-from=self.applicationBytes;
    ProtocolOpcode::EXTENDED_REQUEST        -> EXTENDED_REQUEST:        ExtendedRequest(self)       &parse-from=self.applicationBytes;
    ProtocolOpcode::EXTENDED_RESPONSE       -> EXTENDED_RESPONSE:       ExtendedResponse(self)      &parse-from=self.applicationBytes;
    ProtocolOpcode::INTERMEDIATE_RESPONSE   -> INTERMEDIATE_RESPONSE:   IntermediateResponse(self)  &parse-from=self.applicationBytes;
  };

};

#-----------------------------------------------------------------------------
# Bind Operation
# https://tools.ietf.org/html/rfc4511#section-4.2

type BindAuthType = enum {
  BIND_AUTH_SIMPLE = 0,
  BIND_AUTH_SASL = 3,
  NOT_SET = 127
};

type SaslCredentials = unit(depth: uint32) {
  mechanism: asn1::ASN1Message(True, depth) &convert=$$.body.octetstring;
  # TODO: if we want to parse the (optional) credentials string
};

type BindRequest = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  version: asn1::ASN1Message(True, self.depth) &convert=$$.body.num_value;
  name: asn1::ASN1Message(True, self.depth) &convert=$$.body.octetstring;
  var authType: BindAuthType = BindAuthType::NOT_SET;
  var simpleCreds: string = "";

  authentication: asn1::ASN1Message(True, self.depth) {
    if (self.authentication?.application_id) {
      self.authType = cast<BindAuthType>(cast<uint8>(self.authentication.application_id));
    }
    if ((! self?.authType) || (self.authType == BindAuthType::NOT_SET)) {
      throw "BindRequest is not ASN.1 sequence as described in RFC 4511";
    }
    if ((self.authType == BindAuthType::BIND_AUTH_SIMPLE) &&
        (|self.authentication.application_data| > 0)) {
      self.simpleCreds = self.authentication.application_data.decode();
    }
  }
  saslCreds: SaslCredentials(self.depth+1) &parse-from=self.authentication.application_data if (self.authType == BindAuthType::BIND_AUTH_SASL);

  on %done {
    message.obj = self.name;
    if (|self.simpleCreds| > 0) {
      message.arg = self.simpleCreds;
    } else if (self.authType == BindAuthType::BIND_AUTH_SASL) {
      message.arg = self.saslCreds.mechanism;
    }
    print "BindRequest", message.messageID, self.version, self.name,
          self.authType, message.obj, message.arg;
  }
};

type BindResponse = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  result: Result(self.depth+1);

  # TODO: if we want to parse SASL credentials returned

  on %done {
    message.result = self.result;
    print "BindResponse", message.messageID, self;
  }
};

#-----------------------------------------------------------------------------
# Unbind Operation
# https://tools.ietf.org/html/rfc4511#section-4.3

type UnbindRequest = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  on %done {
    print "UnbindRequest", message.messageID, self;
  }
};

#-----------------------------------------------------------------------------
# Search Operation
# https://tools.ietf.org/html/rfc4511#section-4.5

public type SearchScope = enum {
  SEARCH_BASE    = 0,
  SEARCH_SINGLE  = 1,
  SEARCH_TREE    = 2,
  NOT_SET        = 255
};

public type SearchDerefAlias = enum {
  DEREF_NEVER        = 0,
  DEREF_IN_SEARCHING = 1,
  DEREF_FINDING_BASE = 2,
  DEREF_ALWAYS       = 3,
  NOT_SET            = 255
};

type FilterType = enum {
  FILTER_AND     = 0,
  FILTER_OR      = 1,
  FILTER_NOT     = 2,
  FILTER_EQ      = 3,
  FILTER_SUBSTR  = 4,
  FILTER_GE      = 5,
  FILTER_LE      = 6,
  FILTER_PRESENT = 7,
  FILTER_APPROX  = 8,
  FILTER_EXT     = 9,
  FILTER_INVALID = 254,
  NOT_SET        = 255
};

type AttributeSelection = unit(depth: uint32) {
  var attributes: vector<string>;

  # TODO: parse AttributeSelection as per
  # https://tools.ietf.org/html/rfc4511#section-4.5.1
  # and decide how deep that should be fleshed out.
  seq: asn1::ASN1Message(True, depth) {
    if ((self.seq.head.tag.tpe == asn1::ASN1Type::SEQUENCE) &&
        (self.seq.body?.seq) &&
        (|self.seq.body.seq.submessages| > 0)) {
      for (i in self.seq.body.seq.submessages) {
        if (i.body?.octetstring) {
          self.attributes.push_back(i.body.octetstring);
        }
      }
    }
  }
};

type AttributeValueAssertion = unit(depth: uint32) {
  var desc: string = "";
  var val: string = "";

  seq: asn1::ASN1Message(True, depth) {
    if ((self.seq.head.tag.tpe == asn1::ASN1Type::SEQUENCE) &&
        (self.seq.body?.seq) &&
        (|self.seq.body.seq.submessages| >= 2)) {
      if (self.seq.body.seq.submessages[0].body?.octetstring) {
        self.desc = self.seq.body.seq.submessages[0].body.octetstring;
      }
      if (self.seq.body.seq.submessages[1].body?.octetstring) {
        self.val = self.seq.body.seq.submessages[1].body.octetstring;
      }
    }
  }

};

type SubstringFilter = unit(depth: uint32) {
  var ftype: string = "";
  var substrings: asn1::ASN1Message;

  seq: asn1::ASN1Message(True, depth) {
    if ((self.seq.head.tag.tpe == asn1::ASN1Type::SEQUENCE) &&
        (self.seq.body?.seq) &&
        (|self.seq.body.seq.submessages| >= 2)) {
      if (self.seq.body.seq.submessages[0].body?.octetstring) {
        self.ftype = self.seq.body.seq.submessages[0].body.octetstring;
      }
      if (self.seq.body.seq.submessages[1].head.tag.tpe == asn1::ASN1Type::SEQUENCE) {
        self.substrings = self.seq.body.seq.submessages[1];
      }
    }
    # TODO: if we want to descend deeper into the substrings filter
    # if (self?.substrings) {
    #
    #}
  }

};

type SearchFilter = unit(depth: uint32) {
  var filterType: FilterType = FilterType::NOT_SET;
  var filterBytes: bytes = b"";

  filter : asn1::ASN1Message(True, depth) {
    if (self.filter?.application_id) {
      self.filterType = cast<FilterType>(cast<uint8>(self.filter.application_id));
      self.filterBytes = self.filter.application_data;
    } else {
      self.filterType = FilterType::FILTER_INVALID;
    }
  }

  # TODO: parse search request filter as per
  #    https://tools.ietf.org/html/rfc4511#section-4.5.1.7
  # This descent gets pretty involved... I wonder what is
  # the best way to represent this as a string in a log.
  # I've just left some of them as asn1::ASN1Message for now.

  switch ( self.filterType ) {
    FilterType::FILTER_AND     -> FILTER_AND:     asn1::ASN1Message(True, depth+1)
                                                  &parse-from=self.filterBytes;
    FilterType::FILTER_OR      -> FILTER_OR:      asn1::ASN1Message(True, depth+1)
                                                  &parse-from=self.filterBytes;
    FilterType::FILTER_NOT     -> FILTER_NOT:     SearchFilter(depth+1)
                                                  &parse-from=self.filterBytes;
    FilterType::FILTER_EQ      -> FILTER_EQ:      AttributeValueAssertion(depth+1)
                                                  &parse-from=self.filterBytes;
    FilterType::FILTER_SUBSTR  -> FILTER_SUBSTR:  SubstringFilter(depth+1)
                                                  &parse-from=self.filterBytes;
    FilterType::FILTER_GE      -> FILTER_GE:      AttributeValueAssertion(depth+1)
                                                  &parse-from=self.filterBytes;
    FilterType::FILTER_LE      -> FILTER_LE:      AttributeValueAssertion(depth+1)
                                                  &parse-from=self.filterBytes;
    FilterType::FILTER_PRESENT -> FILTER_PRESENT: asn1::ASN1OctetString(self.filter.head.len.len, False)
                                                  &convert=$$.value.decode(hilti::Charset::ASCII)
                                                  &parse-from=self.filterBytes;
    FilterType::FILTER_APPROX  -> FILTER_APPROX:  AttributeValueAssertion(depth+1)
                                                  &parse-from=self.filterBytes;
    FilterType::FILTER_EXT     -> FILTER_EXT:     asn1::ASN1Message(True, depth+1)
                                                  &parse-from=self.filterBytes;
    * -> unknownFilter: void;
  };
};

type SearchRequest = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  baseObject: asn1::ASN1Message(True, self.depth) &convert=$$.body.octetstring;
  scope: asn1::ASN1Message(True, self.depth) &convert=cast<SearchScope>(cast<uint8>($$.body.num_value))
                                             &default=SearchScope::NOT_SET;
  deref: asn1::ASN1Message(True, self.depth) &convert=cast<SearchDerefAlias>(cast<uint8>($$.body.num_value))
                                             &default=SearchDerefAlias::NOT_SET;
  sizeLimit: asn1::ASN1Message(True, self.depth) &convert=$$.body.num_value &default=0;
  timeLimit: asn1::ASN1Message(True, self.depth) &convert=$$.body.num_value &default=0;
  typesOnly: asn1::ASN1Message(True, self.depth) &convert=$$.body.bool_value &default=False;
  filter: SearchFilter(self.depth);
  attributes: AttributeSelection(self.depth);

  on %done {
    message.obj = self.baseObject;
    message.arg = "%s" % self.scope;
    print "SearchRequest", message.messageID, self;
  }
};

type SearchResultEntry = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  objectName: asn1::ASN1Message(True, self.depth) &convert=$$.body.octetstring;
  # TODO: if we want to descend down into PartialAttributeList
  attributes: asn1::ASN1Message(True, self.depth);

  on %done {
    message.obj = self.objectName;
    print "SearchResultEntry", message.messageID, self;
  }
};

type SearchResultDone = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  result: Result(self.depth+1);

  on %done {
    message.result = self.result;
    print "SearchResultDone", message.messageID, self;
  }
};

type SearchResultReference = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  # TODO: SearchResultReference
  # The SearchResultReference is of the same data type as the Referral.

  on %done {
    print "SearchResultReference", message.messageID, self;
  }
};

#-----------------------------------------------------------------------------
# Modify Operation
# https://tools.ietf.org/html/rfc4511#section-4.6

type ModifyRequest = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  objectName: asn1::ASN1Message(True, self.depth) &convert=$$.body.octetstring;

  # TODO: parse changes

  on %done {
    message.obj = self.objectName;
    print "ModifyRequest", message.messageID, self;
  }
};

type ModifyResponse = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  result: Result(self.depth+1);

  on %done {
    message.result = self.result;
    print "ModifyResponse", message.messageID, self;
  }
};

#-----------------------------------------------------------------------------
# Add Operation
# https://tools.ietf.org/html/rfc4511#section-4.7

type AddRequest = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  # TODO: add request sequence

  on %done {
    print "AddRequest", message.messageID, self;
  }
};

type AddResponse = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  result: Result(self.depth+1);

  on %done {
    message.result = self.result;
    print "AddResponse", message.messageID, self;
  }
};

#-----------------------------------------------------------------------------
# Delete Operation
# https://tools.ietf.org/html/rfc4511#section-4.8

type DelRequest = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  objectName: asn1::ASN1Message(True, self.depth) &convert=$$.body.octetstring;

  on %done {
    message.obj = self.objectName;
    print "DelRequest", message.messageID, self;
  }
};

type DelResponse = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  result: Result(self.depth+1);

  on %done {
    message.result = self.result;
    print "DelResponse", message.messageID, self;
  }
};

#-----------------------------------------------------------------------------
# Modify DN Operation
# https://tools.ietf.org/html/rfc4511#section-4.8

type ModDNRequest = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  # TODO: parse mod DN request sequence

  on %done {
    print "ModDNRequest", message.messageID, self;
  }
};

type ModDNResponse = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  result: Result(self.depth+1);

  on %done {
    message.result = self.result;
    print "ModDNResponse", message.messageID, self;
  }
};

#-----------------------------------------------------------------------------
# Compare Operation
# https://tools.ietf.org/html/rfc4511#section-4.10

type CompareRequest = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  # TODO: parse compare request entry/ava sequence

  on %done {
    print "CompareRequest", message.messageID, self;
  }
};

type CompareResponse = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  result: Result(self.depth+1);

  on %done {
    message.result = self.result;
    print "CompareResponse", message.messageID, self;
  }
};

#-----------------------------------------------------------------------------
# Abandon Operation
# https://tools.ietf.org/html/rfc4511#section-4.11

type AbandonRequest = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;
  # messageID: asn1::ASN1Message(True, self.depth) &convert=$$.body.num_value;

  on %done {
    # TODO: can't do string -> bytes
    # but see https://github.com/zeek/spicy/issues/911 for next release
    # message.obj = "%d" % (self.messageID);
    print "AbandonRequest", message.messageID, self;
  }
};

#-----------------------------------------------------------------------------
# Extended Operation
# https://tools.ietf.org/html/rfc4511#section-4.12

type ExtendedRequest = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  # TODO: parse ExtendedRequest sequence

  on %done {
    print "ExtendedRequest", message.messageID, self;
  }
};

type ExtendedResponse = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  # TODO: parse ExtendedRequest sequence

  on %done {
    # message.result = self.result;
    print "ExtendedResponse", message.messageID, self;
  }
};

#-----------------------------------------------------------------------------
# IntermediateResponse Message
# https://tools.ietf.org/html/rfc4511#section-4.13

type IntermediateResponse = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  # TODO: parse IntermediateResponse sequence

  on %done {
    print "IntermediateResponse", message.messageID, self;
  }
};
