module ldap;

import asn1;

# https://tools.ietf.org/html/rfc4511

#- Operation opcode ----------------------------------------------------------
public type ProtocolOpcode = enum {
  BIND_REQUEST = 0,
  BIND_RESPONSE = 1,
  UNBIND_REQUEST = 2,
  SEARCH_REQUEST = 3,
  SEARCH_RESULT_ENTRY = 4,
  SEARCH_RESULT_DONE = 5,
  MODIFY_REQUEST = 6,
  MODIFY_RESPONSE = 7,
  ADD_REQUEST = 8,
  ADD_RESPONSE = 9,
  DEL_REQUEST = 10,
  DEL_RESPONSE = 11,
  MOD_DN_REQUEST = 12,
  MOD_DN_RESPONSE = 13,
  COMPARE_REQUEST = 14,
  COMPARE_RESPONSE = 15,
  ABANDON_REQUEST = 16,
  SEARCH_RESULT_REFERENCE = 19,
  EXTENDED_REQUEST = 23,
  EXTENDED_RESPONSE = 24,
  INTERMEDIATE_RESPONSE = 25,
  NOT_SET = 255
};

#- Result code ---------------------------------------------------------------
public type ResultCode = enum {
  SUCCESS = 0,
  OPERATIONS_ERROR = 1,
  PROTOCOL_ERROR = 2,
  TIME_LIMIT_EXCEEDED = 3,
  SIZE_LIMIT_EXCEEDED = 4,
  COMPARE_FALSE = 5,
  COMPARE_TRUE = 6,
  AUTH_METHOD_NOT_SUPPORTED = 7,
  STRONGER_AUTH_REQUIRED = 8,
  REFERRAL = 10,
  ADMIN_LIMIT_EXCEEDED = 11,
  UNAVAILABLE_CRITICAL_EXTENSION = 12,
  CONFIDENTIALITY_REQUIRED = 13,
  SASL_BIND_IN_PROGRESS = 14,
  NO_SUCH_ATTRIBUTE = 16,
  UNDEFINED_ATTRIBUTE_TYPE = 17,
  INAPPROPRIATE_MATCHING = 18,
  CONSTRAINT_VIOLATION = 19,
  ATTRIBUTE_OR_VALUE_EXISTS = 20,
  INVALID_ATTRIBUTE_SYNTAX = 21,
  NO_SUCH_OBJECT = 32,
  ALIAS_PROBLEM = 33,
  INVALID_DNSYNTAX = 34,
  ALIAS_DEREFERENCING_PROBLEM = 36,
  INAPPROPRIATE_AUTHENTICATION = 48,
  INVALID_CREDENTIALS = 49,
  INSUFFICIENT_ACCESS_RIGHTS = 50,
  BUSY = 51,
  UNAVAILABLE = 52,
  UNWILLING_TO_PERFORM = 53,
  LOOP_DETECT = 54,
  NAMING_VIOLATION = 64,
  OBJECT_CLASS_VIOLATION = 65,
  NOT_ALLOWED_ON_NON_LEAF = 66,
  NOT_ALLOWED_ON_RDN = 67,
  ENTRY_ALREADY_EXISTS = 68,
  OBJECT_CLASS_MODS_PROHIBITED = 69,
  AFFECTS_MULTIPLE_DSAS = 71,
  OTHER = 80,
  NOT_SET = 255
};

#-----------------------------------------------------------------------------
public type Result = unit(depth: uint32) {
  code: asn1::ASN1Message(True, depth) &convert=cast<ResultCode>(cast<uint8>($$.body.num_value))
                                       &default=ResultCode::NOT_SET;
  matchedDN: asn1::ASN1Message(True, depth) &convert=$$.body.octetstring.value
                                            &default=b"";
  diagnosticMessage: asn1::ASN1Message(True, depth) &convert=$$.body.octetstring.value
                                                    &default=b"";

  # TODO: parse referral
  # https://tools.ietf.org/html/rfc4511#section-4.1.10
};

#-----------------------------------------------------------------------------
public type Messages = unit {
  : Message[];
};

public type Message = unit {
  var messageID: int64;
  var opcode: ProtocolOpcode = ProtocolOpcode::NOT_SET;
  var applicationBytes: bytes;
  var unsetResultDefault: Result;
  var result: Result& = self.unsetResultDefault;
  var obj: bytes = b"";
  var arg: bytes = b"";

  seq: asn1::ASN1Message(True, 0) {
    if ((self.seq.head.tag.tpe == asn1::ASN1Type::SEQUENCE) &&
        (self.seq.body?.seq) &&
        (|self.seq.body.seq.submessages| >= 2)) {
      if (self.seq.body.seq.submessages[0].body?.num_value) {
        self.messageID = self.seq.body.seq.submessages[0].body.num_value;
      }
      if (self.seq.body.seq.submessages[1]?.application_id) {
        self.opcode = cast<ProtocolOpcode>(cast<uint8>(self.seq.body.seq.submessages[1].application_id));
        self.applicationBytes = self.seq.body.seq.submessages[1].application_data;
      }
    }
    if ((! self.?messageID) ||
        (! self.?opcode) ||
        (self.opcode == ProtocolOpcode::NOT_SET)) {
      throw "LDAP message is not ASN.1 sequence as described in RFC 4511";
    }
  }

  switch ( self.opcode ) {
    ProtocolOpcode::BIND_REQUEST -> BIND_REQUEST: BindRequest(self) &parse-from=self.applicationBytes;
    ProtocolOpcode::BIND_RESPONSE -> BIND_RESPONSE: BindResponse(self) &parse-from=self.applicationBytes;
    ProtocolOpcode::UNBIND_REQUEST -> UNBIND_REQUEST: UnbindRequest(self) &parse-from=self.applicationBytes;
    ProtocolOpcode::SEARCH_REQUEST -> SEARCH_REQUEST: SearchRequest(self) &parse-from=self.applicationBytes;
    ProtocolOpcode::SEARCH_RESULT_ENTRY -> SEARCH_RESULT_ENTRY: SearchResultEntry(self) &parse-from=self.applicationBytes;
    ProtocolOpcode::SEARCH_RESULT_DONE -> SEARCH_RESULT_DONE: SearchResultDone(self) &parse-from=self.applicationBytes;
    ProtocolOpcode::MODIFY_REQUEST -> MODIFY_REQUEST: ModifyRequest(self) &parse-from=self.applicationBytes;
    ProtocolOpcode::MODIFY_RESPONSE -> MODIFY_RESPONSE: ModifyResponse(self) &parse-from=self.applicationBytes;
    ProtocolOpcode::ADD_REQUEST -> ADD_REQUEST: AddRequest(self) &parse-from=self.applicationBytes;
    ProtocolOpcode::ADD_RESPONSE -> ADD_RESPONSE: AddResponse(self) &parse-from=self.applicationBytes;
    ProtocolOpcode::DEL_REQUEST -> DEL_REQUEST: DelRequest(self) &parse-from=self.applicationBytes;
    ProtocolOpcode::DEL_RESPONSE -> DEL_RESPONSE: DelResponse(self) &parse-from=self.applicationBytes;
    ProtocolOpcode::MOD_DN_REQUEST -> MOD_DN_REQUEST: ModDNRequest(self) &parse-from=self.applicationBytes;
    ProtocolOpcode::MOD_DN_RESPONSE -> MOD_DN_RESPONSE: ModDNResponse(self) &parse-from=self.applicationBytes;
    ProtocolOpcode::COMPARE_REQUEST -> COMPARE_REQUEST: CompareRequest(self) &parse-from=self.applicationBytes;
    ProtocolOpcode::COMPARE_RESPONSE -> COMPARE_RESPONSE: CompareResponse(self) &parse-from=self.applicationBytes;
    ProtocolOpcode::ABANDON_REQUEST -> ABANDON_REQUEST: AbandonRequest(self) &parse-from=self.applicationBytes;
    ProtocolOpcode::SEARCH_RESULT_REFERENCE -> SEARCH_RESULT_REFERENCE: SearchResultReference(self) &parse-from=self.applicationBytes;
    ProtocolOpcode::EXTENDED_REQUEST -> EXTENDED_REQUEST: ExtendedRequest(self) &parse-from=self.applicationBytes;
    ProtocolOpcode::EXTENDED_RESPONSE -> EXTENDED_RESPONSE: ExtendedResponse(self) &parse-from=self.applicationBytes;
    ProtocolOpcode::INTERMEDIATE_RESPONSE -> INTERMEDIATE_RESPONSE: IntermediateResponse(self) &parse-from=self.applicationBytes;
  };

};

#-----------------------------------------------------------------------------
# Bind Operation
# https://tools.ietf.org/html/rfc4511#section-4.2

type BindAuthType = enum {
  BIND_AUTH_SIMPLE = 0,
  BIND_AUTH_SASL = 3,
  NOT_SET = 127
};

type SaslCredentials = unit(depth: uint32) {
  mechanism: asn1::ASN1Message(True, depth) &convert=$$.body.octetstring.value;
  # TODO: if we want to parse more out of this (optional) credentials string
  # credentials: asn1::ASN1Message(True, depth) &convert=$$.body.octetstring.value;
};

type BindRequest = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  version: asn1::ASN1Message(True, self.depth) &convert=$$.body.num_value;
  name: asn1::ASN1Message(True, self.depth) &convert=$$.body.octetstring.value;
  var authType: BindAuthType = BindAuthType::NOT_SET;
  var simpleCreds: bytes = b"";

  authentication: asn1::ASN1Message(True, self.depth) {
    if (self.authentication.head.tag.class == asn1::ASN1Class::CONTEXT_SPECIFIC) {
      self.authType = cast<BindAuthType>(self.authentication.head.tag.data.num);
    }
    if ((! self.?authType) || (self.authType == BindAuthType::NOT_SET)) {
      throw "BindRequest is not ASN.1 sequence as described in RFC 4511";
    }
    if ((self.authType == BindAuthType::BIND_AUTH_SIMPLE) &&
        (|self.authentication.application_data| > 0)) {
      self.simpleCreds = self.authentication.application_data;
    }
  }
  saslCreds: SaslCredentials(self.depth+1) &parse-from=self.authentication.application_data if (self.authType == BindAuthType::BIND_AUTH_SASL);

  on %done {
    message.obj = self.name;
    if (|self.simpleCreds| > 0) {
      message.arg = self.simpleCreds;
    } else if (self.authType == BindAuthType::BIND_AUTH_SASL) {
      message.arg = self.saslCreds.mechanism;
    }
    print "BindRequest", message.messageID, self.version, self.name,
          self.authType, message.obj, message.arg;
  }
};

type BindResponse = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  result: Result(self.depth+1);

  # TODO: if we want to parse SASL credentials returned

  on %done {
    # message.result = self.result;
    print "BindResponse", message.messageID, self;
  }
};

#-----------------------------------------------------------------------------
# Unbind Operation
# https://tools.ietf.org/html/rfc4511#section-4.3

type UnbindRequest = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  on %done {
    print "UnbindRequest", message.messageID, self;
  }
};

#-----------------------------------------------------------------------------
# Search Operation
# https://tools.ietf.org/html/rfc4511#section-4.5

public type SearchScope = enum {
  SEARCH_BASE = 0,
  SEARCH_SINGLE = 1,
  SEARCH_TREE = 2,
  SEARCH_NOT_SET = 255
};

public type SearchDerefAlias = enum {
  DEREF_NEVER = 0,
  DEREF_IN_SEARCHING = 1,
  DEREF_FINDING_BASE = 2,
  DEREF_ALWAYS = 3,
  DEREF_NOT_SET = 255
};

type FilterType = enum {
  FILTER_AND = 0,
  FILTER_OR = 1,
  FILTER_NOT = 2,
  FILTER_EQ = 3,
  FILTER_SUBSTR = 4,
  FILTER_GE = 5,
  FILTER_LE = 6,
  FILTER_PRESENT = 7,
  FILTER_APPROX = 8,
  FILTER_EXT = 9,
  FILTER_INVALID = 254,
  FILTER_NOT_SET = 255
};

#type AttributeSelection = unit() {
#  # TODO: parse AttributeSelection as per
#  # https://tools.ietf.org/html/rfc4511#section-4.5.1
#  # and decide how deep that should be fleshed out.
#  # attributes : asn1::ASN1MessageBase;
#};
#
#type AttributeValueAssertion = unit() {
#  head: asn1::ASN1Header;
#  sequence: asn1::ASN1MessageHeadless(self.head, False, 0)
#    if (self.head.tag.tpe == asn1::ASN1Type::SEQUENCE);
#  description: asn1::ASN1MessageBase &convert=$$.body.octetstring
#    if (self.head.tag.tpe == asn1::ASN1Type::SEQUENCE);
#  value: asn1::ASN1MessageBase &convert=$$.body.octetstring
#    if (self.head.tag.tpe == asn1::ASN1Type::SEQUENCE);
#};
#
#type SearchFilter = unit() {
#  var filterType: FilterType = FilterType::FILTER_NOT_SET;
#  filter : asn1::ASN1MessageBase {
#    if ((self.filter.head.tag.tpe == asn1::ASN1Type::ObjectDescriptor) &&
#        (self.filter.head.tag.class == asn1::ASN1Class::CONTEXT_SPECIFIC)) {
#      self.filterType = cast<FilterType>(self.filter.head.tag.data.num);
#    } else {
#      self.filterType = FilterType::FILTER_INVALID;
#    }
#  }
#
#  # TODO: parse search request filter as per
#  #    https://tools.ietf.org/html/rfc4511#section-4.5.1.7
#  # This gets pretty involved... I wonder about the best way
#  # to represent this (beyond just descending the object tree)
#
#  switch ( self.filterType ) {
#    # FilterType::FILTER_AND -> FILTER_AND: void;
#    # FilterType::FILTER_OR -> FILTER_OR: void;
#    # FilterType::FILTER_SUBSTR -> FILTER_SUBSTR: void;
#    # FilterType::FILTER_EXT -> FILTER_EXT: void;
#    FilterType::FILTER_NOT -> FILTER_NOT: SearchFilter();
#    FilterType::FILTER_EQ -> FILTER_EQ: AttributeValueAssertion();
#    FilterType::FILTER_GE -> FILTER_GE: AttributeValueAssertion();
#    FilterType::FILTER_LE -> FILTER_LE: AttributeValueAssertion();
#    FilterType::FILTER_PRESENT -> FILTER_PRESENT: asn1::ASN1OctetString(self.filter.head.len.len, 0);
#    FilterType::FILTER_APPROX -> FILTER_APPROX: AttributeValueAssertion();
#    * -> unknownFilter: bytes &size=self.filter.head.len.len;
#  };
#};

type SearchRequest = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;
#  baseObject: asn1::ASN1MessageBase &convert=$$.body.octetstring;
#  scope: asn1::ASN1MessageBase &convert=cast<SearchScope>(cast<uint8>($$.body.num_value))
#                           &default=SearchScope::SEARCH_NOT_SET;
#  deref: asn1::ASN1MessageBase &convert=cast<SearchDerefAlias>(cast<uint8>($$.body.num_value))
#                           &default=SearchDerefAlias::DEREF_NOT_SET;
#  sizeLimit: asn1::ASN1MessageBase &convert=$$.body.num_value;
#  timeLimit: asn1::ASN1MessageBase &convert=$$.body.num_value;
#  typesOnly: asn1::ASN1MessageBase &convert=cast<bool>($$.body.bool_value);
#  filter: SearchFilter;
#  attributes: AttributeSelection;

  on %done {
    # message.obj = self.baseObject.value;
    print "SearchRequest", message.messageID, self;
  }
};

type SearchResultEntry = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;
  # objectName: asn1::ASN1MessageBase &convert=$$.body.octetstring;

  # TODO: parse attributes PartialAttributeList

  on %done {
    # message.obj = self.objectName.value;
    print "SearchResultEntry", message.messageID, self;
  }
};

type SearchResultDone = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;
  # result: Result;

  on %done {
    # message.result = self.result;
    print "SearchResultDone", message.messageID, self;
  }
};

type SearchResultReference = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  # TODO: SearchResultReference
  # The SearchResultReference is of the same data type as the Referral.

  on %done {
    print "SearchResultReference", message.messageID, self;
  }
};

#-----------------------------------------------------------------------------
# Modify Operation
# https://tools.ietf.org/html/rfc4511#section-4.6

type ModifyRequest = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;
  # objectName: asn1::ASN1MessageBase &convert=$$.body.octetstring;

  # TODO: parse changes

  on %done {
    # message.obj = self.objectName.value;
    print "ModifyRequest", message.messageID, self;
  }
};

type ModifyResponse = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;
  # result: Result;

  on %done {
    # message.result = self.result;
    print "ModifyResponse", message.messageID, self;
  }
};

#-----------------------------------------------------------------------------
# Add Operation
# https://tools.ietf.org/html/rfc4511#section-4.7

type AddRequest = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  # TODO: add request sequence

  on %done {
    print "AddRequest", message.messageID, self;
  }
};

type AddResponse = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;
  # result: Result;

  on %done {
    # message.result = self.result;
    print "AddResponse", message.messageID, self;
  }
};

#-----------------------------------------------------------------------------
# Delete Operation
# https://tools.ietf.org/html/rfc4511#section-4.8

type DelRequest = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;
  # objectName: asn1::ASN1MessageBase &convert=$$.body.octetstring;

  on %done {
    # message.obj = self.objectName.value;
    print "DelRequest", message.messageID, self;
  }
};

type DelResponse = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;
  # result: Result;

  on %done {
    # message.result = self.result;
    print "DelResponse", message.messageID, self;
  }
};

#-----------------------------------------------------------------------------
# Modify DN Operation
# https://tools.ietf.org/html/rfc4511#section-4.8

type ModDNRequest = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  # TODO: parse mod DN request sequence

  on %done {
    print "ModDNRequest", message.messageID, self;
  }
};

type ModDNResponse = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;
  # result: Result;

  on %done {
    # message.result = self.result;
    print "ModDNResponse", message.messageID, self;
  }
};

#-----------------------------------------------------------------------------
# Compare Operation
# https://tools.ietf.org/html/rfc4511#section-4.10

type CompareRequest = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;

  # TODO: parse compare request entry/ava sequence

  on %done {
    print "CompareRequest", message.messageID, self;
  }
};

type CompareResponse = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;
  # result: Result;

  on %done {
    # message.result = self.result;
    print "CompareResponse", message.messageID, self;
  }
};

#-----------------------------------------------------------------------------
# Abandon Operation
# https://tools.ietf.org/html/rfc4511#section-4.11

type AbandonRequest = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;
  # messageID: asn1::ASN1MessageBase &convert=$$.body.num_value;

  on %done {
    # TODO: can't do string -> bytes
    # message.obj = "%d" % (self.messageID);
    print "AbandonRequest", message.messageID, self;
  }
};

#-----------------------------------------------------------------------------
# Extended Operation
# https://tools.ietf.org/html/rfc4511#section-4.12

type ExtendedRequest = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;
  # TODO: parse ExtendedRequest sequence

  on %done {
    print "ExtendedRequest", message.messageID, self;
  }
};

type ExtendedResponse = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;
  # TODO: parse ExtendedRequest sequence

  on %done {
    # message.result = self.result;
    print "ExtendedResponse", message.messageID, self;
  }
};

#-----------------------------------------------------------------------------
# IntermediateResponse Message
# https://tools.ietf.org/html/rfc4511#section-4.13

type IntermediateResponse = unit(inout message: Message) {
  var depth: uint32 = message.seq.body.seq.submessages[1].depth+1;
  # TODO: parse IntermediateResponse sequence

  on %done {
    print "IntermediateResponse", message.messageID, self;
  }
};
